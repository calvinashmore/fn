/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.icosilune.fn.processor;

import com.google.auto.service.AutoService;
import com.google.common.collect.Iterables;
import com.icosilune.fn.Fn;
import java.io.IOException;
import java.io.Writer;
import java.util.Set;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.lang.model.element.Element;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;

/**
 *
 * @author ashmore
 */
@AutoService(Processor.class)
@SupportedAnnotationTypes("com.icosilune.fn.Fn")
public class FnProcessor extends AbstractProcessor {

  @Override
  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
    Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(Fn.class);

    for(TypeElement type : Iterables.filter(elements, TypeElement.class)) {
      processType(type);
    }

    // supposedly we should return false, but dunno?
    return true;
  }

  private void processType(TypeElement type) {

    // assert that type extends AbstractFn

    String filename = "Fn_"+type.getSimpleName();
    writeSourceFile(filename, generateSource(type), type);
  }

  private String generateSource(TypeElement type) {
    // later what we're going to do is build something that maps the type (or perhaps just name)
    // of an AbstractFn to the class generated by this.

    StringBuilder sb = new StringBuilder();
    sb.append("package "+packageNameOf(type)+";\n");
    // add all imports used by the underlying type?
    // or just enough to implement AbstractFn
    sb.append("public final class "+type.getSimpleName()+"_Fn extends "+type.getSimpleName()+" {\n");

    // implement getInputTypes

    // implement getOutputTypes
    // ***** FOR NOW: only assume SINGLE output type.

    // implement evaluateWrapper
    sb.append("}\n");



    return sb.toString();
  }

    static String packageNameOf(TypeElement type) {
    while (true) {
      Element enclosing = type.getEnclosingElement();
      if (enclosing instanceof PackageElement) {
        return ((PackageElement) enclosing).getQualifiedName().toString();
      }
      type = (TypeElement) enclosing;
    }
  }

  private void writeSourceFile(String className, String text, TypeElement originatingType) {
    try {
      JavaFileObject sourceFile =
          processingEnv.getFiler().createSourceFile(className, originatingType);
      try (Writer writer = sourceFile.openWriter()) {
        writer.write(text);
      }
    } catch (IOException e) {
      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
          "Could not write generated class " + className + ": " + e);
    }
  }
}
